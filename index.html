<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Knightmare - Mobile Chess Game</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #8B4513;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            width: min(90vw, 400px);
            height: min(90vw, 400px);
            margin: 0 auto;
        }
        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(24px, 5vw, 36px);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        .light-square { background-color: #f0d9b5; }
        .dark-square { background-color: #b58863; }
        .selected { box-shadow: inset 0 0 0 3px #ff6b6b !important; }
        .possible-move { 
            box-shadow: inset 0 0 0 3px #4ecdc4 !important;
            background: radial-gradient(circle, rgba(78,205,196,0.3) 30%, transparent 30%);
        }
        .last-move { box-shadow: inset 0 0 0 3px #ffd93d !important; }
        .in-check { box-shadow: inset 0 0 0 3px #ff4757 !important; }
        .piece {
            user-select: none;
            transition: transform 0.2s ease;
            pointer-events: none;
        }
        .chess-square:active {
            transform: scale(0.95);
        }
        .move-history {
            max-height: 200px;
            overflow-y: auto;
        }
        .captured-pieces {
            min-height: 40px;
        }
        .status-indicator {
            height: 4px;
            transition: all 0.3s ease;
        }
        .control-button {
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        .control-button:active {
            transform: translateY(1px);
        }
        .hint-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 193, 7, 0.7);
            border-radius: 50%;
            pointer-events: none;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            z-index: 1000;
            transition: transform 0.3s ease;
            max-width: 90vw;
        }
        .notification.show {
            transform: translateX(-50%) translateY(0);
        }
        .mobile-panel {
            transition: all 0.3s ease;
            max-height: 0;
            overflow: hidden;
        }
        .mobile-panel.open {
            max-height: 1000px;
        }
        .bottom-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e5e5e5;
            z-index: 50;
        }
        .floating-info {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 40;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        @media (max-width: 768px) {
            .chess-board {
                width: min(95vw, 350px);
                height: min(95vw, 350px);
            }
            .desktop-sidebar {
                display: none;
            }
        }
        @media (min-width: 769px) {
            .mobile-only {
                display: none;
            }
            .bottom-controls {
                position: relative;
                border-top: none;
            }
        }
        .touch-feedback {
            background: rgba(0,0,0,0.1);
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .modal-content {
            background: white;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 80vh;
            overflow-y: auto;
        }
        .hamburger-menu {
            display: flex;
            flex-direction: column;
            width: 24px;
            height: 18px;
            cursor: pointer;
        }
        .hamburger-line {
            width: 100%;
            height: 2px;
            background: currentColor;
            transition: 0.3s;
            margin: 2px 0;
        }
        .hamburger-menu.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }
        .hamburger-menu.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        .hamburger-menu.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -6px);
        }
        .coordinate-labels {
            position: absolute;
            font-size: 12px;
            color: #666;
            pointer-events: none;
        }
        .file-label {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        .rank-label {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
        }
        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .animate-slide-in-left {
            animation: slideInLeft 1s ease-out forwards;
        }
        .touch-ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
        }
        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 min-h-screen">
    <!-- Notification System -->
    <div id="notification" class="notification bg-white rounded-lg shadow-lg p-3">
        <div class="flex items-center">
            <i class="fas fa-info-circle text-blue-500 mr-2"></i>
            <span id="notification-text" class="text-gray-800 text-sm"></span>
        </div>
    </div>

    <!-- Floating Game Info (Mobile) -->
    <div class="floating-info mobile-only">
        <div class="flex items-center space-x-2 text-sm">
            <div id="mobile-current-player" class="font-bold text-gray-800">White</div>
            <div id="mobile-game-status" class="text-gray-600"></div>
        </div>
    </div>

    <div class="container mx-auto px-2 py-4 pb-20 md:pb-4">
        <!-- Header -->
        <div class="text-center mb-4">
            <h1 class="text-2xl md:text-4xl font-bold text-white mb-2">
                <i class="fas fa-chess mr-2"></i>
                KNIGHTMARE
            </h1>
            <p class="text-purple-200 text-sm md:text-base">Mobile Chess with AI & Learning Features</p>
        </div>

        <!-- Mobile Menu Toggle -->
        <div class="mobile-only flex justify-between items-center mb-4 px-4">
            <button id="menu-toggle" class="hamburger-menu text-white">
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
                <div class="hamburger-line"></div>
            </button>
            <div class="text-white text-sm">
                <span id="mobile-timer">00:00</span> | Moves: <span id="mobile-moves">0</span>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Game Board Section -->
            <div class="lg:col-span-2">
                <div class="bg-white rounded-xl shadow-2xl p-3 md:p-6">
                    <!-- Desktop Game Status -->
                    <div class="mb-4 hidden md:block">
                        <div class="flex justify-between items-center mb-2">
                            <div class="flex items-center">
                                <div id="current-player" class="text-xl font-bold text-gray-800">White's Turn</div>
                                <div id="game-status" class="ml-4 text-lg text-gray-600"></div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <button id="hint-btn" class="control-button bg-yellow-500 hover:bg-yellow-600 text-white px-3 py-1 rounded-lg text-sm">
                                    <i class="fas fa-lightbulb mr-1"></i>Hint
                                </button>
                                <button id="undo-btn" class="control-button bg-orange-500 hover:bg-orange-600 text-white px-3 py-1 rounded-lg text-sm">
                                    <i class="fas fa-undo mr-1"></i>Undo
                                </button>
                            </div>
                        </div>
                        <div id="status-bar" class="status-indicator bg-blue-500 rounded"></div>
                    </div>

                    <!-- Chess Board Container -->
                    <div class="flex justify-center mb-4 relative">
                        <div class="relative">
                            <div class="chess-board" id="chess-board"></div>
                            <!-- Coordinate Labels -->
                            <div class="coordinate-labels">
                                <!-- File labels (a-h) -->
                                <div class="absolute file-label" style="left: 12.5%;">a</div>
                                <div class="absolute file-label" style="left: 25%;">b</div>
                                <div class="absolute file-label" style="left: 37.5%;">c</div>
                                <div class="absolute file-label" style="left: 50%;">d</div>
                                <div class="absolute file-label" style="left: 62.5%;">e</div>
                                <div class="absolute file-label" style="left: 75%;">f</div>
                                <div class="absolute file-label" style="left: 87.5%;">g</div>
                                <div class="absolute file-label" style="right: 12.5%;">h</div>
                                <!-- Rank labels (1-8) -->
                                <div class="absolute rank-label" style="top: 12.5%;">8</div>
                                <div class="absolute rank-label" style="top: 25%;">7</div>
                                <div class="absolute rank-label" style="top: 37.5%;">6</div>
                                <div class="absolute rank-label" style="top: 50%;">5</div>
                                <div class="absolute rank-label" style="top: 62.5%;">4</div>
                                <div class="absolute rank-label" style="top: 75%;">3</div>
                                <div class="absolute rank-label" style="top: 87.5%;">2</div>
                                <div class="absolute rank-label" style="bottom: 12.5%;">1</div>
                            </div>
                        </div>
                    </div>

                    <!-- Desktop Game Controls -->
                    <div class="justify-center space-x-4 hidden md:flex">
                        <button id="new-game-btn" class="control-button bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-plus mr-2"></i>New Game
                        </button>
                        <button id="ai-move-btn" class="control-button bg-purple-500 hover:bg-purple-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-robot mr-2"></i>AI Move
                        </button>
                        <button id="toggle-ai-btn" class="control-button bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg">
                            <i class="fas fa-brain mr-2"></i>Toggle AI
                        </button>
                    </div>
                </div>
            </div>

            <!-- Desktop Sidebar -->
            <div class="space-y-6 desktop-sidebar">
                <!-- Captured Pieces -->
                <div class="bg-white rounded-xl shadow-lg p-4">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">
                        <i class="fas fa-chess-pawn mr-2"></i>Captured Pieces
                    </h3>
                    <div class="space-y-2">
                        <div>
                            <div class="text-sm text-gray-600 mb-1">White Captured:</div>
                            <div id="white-captured" class="captured-pieces bg-gray-100 rounded p-2 text-xl md:text-2xl"></div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-600 mb-1">Black Captured:</div>
                            <div id="black-captured" class="captured-pieces bg-gray-100 rounded p-2 text-xl md:text-2xl"></div>
                        </div>
                    </div>
                </div>

                <!-- Move History -->
                <div class="bg-white rounded-xl shadow-lg p-4">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">
                        <i class="fas fa-history mr-2"></i>Move History
                    </h3>
                    <div id="move-history" class="move-history text-sm space-y-1"></div>
                </div>

                <!-- Game Statistics -->
                <div class="bg-white rounded-xl shadow-lg p-4">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">
                        <i class="fas fa-chart-bar mr-2"></i>Game Stats
                    </h3>
                    <div class="space-y-2 text-sm">
                        <div class="flex justify-between">
                            <span>Moves Played:</span>
                            <span id="moves-count">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Hints Used:</span>
                            <span id="hints-count">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Game Time:</span>
                            <span id="game-time">00:00</span>
                        </div>
                    </div>
                </div>

                <!-- Chess Learning Tips -->
                <div class="bg-gradient-to-r from-green-400 to-blue-500 rounded-xl shadow-lg p-4 text-white">
                    <h3 class="text-lg font-bold mb-3">
                        <i class="fas fa-graduation-cap mr-2"></i>Chess Tips
                    </h3>
                    <div id="chess-tip" class="text-sm">
                        Control the center of the board with your pawns and pieces. The four central squares (e4, e5, d4, d5) are the most important!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Bottom Controls -->
    <div class="bottom-controls mobile-only">
        <div class="flex flex-wrap gap-2 p-3">
            <button id="mobile-new-game" class="control-button bg-green-500 text-white px-4 py-2 rounded-lg flex-1 text-sm">
                <i class="fas fa-plus mr-1"></i>New
            </button>
            <button id="mobile-undo" class="control-button bg-orange-500 text-white px-4 py-2 rounded-lg flex-1 text-sm">
                <i class="fas fa-undo mr-1"></i>Undo
            </button>
            <button id="mobile-hint" class="control-button bg-yellow-500 text-white px-4 py-2 rounded-lg flex-1 text-sm">
                <i class="fas fa-lightbulb mr-1"></i>Hint
            </button>
        </div>
        <div class="flex gap-2 px-3 pb-3">
            <button id="mobile-ai-move" class="control-button bg-purple-500 text-white px-4 py-2 rounded-lg flex-1 text-sm">
                <i class="fas fa-robot mr-1"></i>AI Move
            </button>
            <button id="mobile-toggle-ai" class="control-button bg-blue-500 text-white px-4 py-2 rounded-lg flex-1 text-sm">
                <i class="fas fa-brain mr-1"></i>AI: OFF
            </button>
        </div>
    </div>

    <!-- Mobile Menu Panel -->
    <div id="mobile-menu" class="mobile-panel mobile-only bg-white mx-4 rounded-lg shadow-lg overflow-hidden">
        <div class="p-4 space-y-4">
            <!-- Captured Pieces -->
            <div>
                <h3 class="text-lg font-bold text-gray-800 mb-2">
                    <i class="fas fa-chess-pawn mr-2"></i>Captured Pieces
                </h3>
                <div class="space-y-2">
                    <div>
                        <div class="text-sm text-gray-600 mb-1">White:</div>
                        <div id="mobile-white-captured" class="bg-gray-100 rounded p-2 text-xl min-h-[40px]"></div>
                    </div>
                    <div>
                        <div class="text-sm text-gray-600 mb-1">Black:</div>
                        <div id="mobile-black-captured" class="bg-gray-100 rounded p-2 text-xl min-h-[40px]"></div>
                    </div>
                </div>
            </div>

            <!-- Move History -->
            <div>
                <h3 class="text-lg font-bold text-gray-800 mb-2">
                    <i class="fas fa-history mr-2"></i>Move History
                </h3>
                <div id="mobile-move-history" class="move-history text-sm space-y-1 max-h-32 overflow-y-auto"></div>
            </div>

            <!-- Game Statistics -->
            <div>
                <h3 class="text-lg font-bold text-gray-800 mb-2">
                    <i class="fas fa-chart-bar mr-2"></i>Game Stats
                </h3>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div class="flex justify-between">
                        <span>Moves:</span>
                        <span id="mobile-moves-count">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Hints:</span>
                        <span id="mobile-hints-count">0</span>
                    </div>
                </div>
            </div>

            <!-- Chess Tips -->
            <div class="bg-gradient-to-r from-green-400 to-blue-500 rounded-lg p-3 text-white">
                <h3 class="font-bold mb-2">
                    <i class="fas fa-graduation-cap mr-2"></i>Chess Tips
                </h3>
                <div id="mobile-chess-tip" class="text-sm">
                    Control the center of the board with your pawns and pieces!
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Template -->
    <!-- <div id="modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 id="modal-title" class="text-xl font-bold text-gray-800"></h3>
                    <button id="modal-close" class="text-gray-500 hover:text-gray-700">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="modal-body" class="text-gray-600"></div>
                <div class="flex justify-end mt-6">
                    <button id="modal-ok" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg">
                        OK
                    </button>
                </div>
            </div>
        </div>
    </div> -->

    <!--Developer Credit-->
    <div class="fixed left-4 top-4 hidden md:block">
        <p class="text-white text-sm font-semibold tracking-widest bg-gray-800 px-2 py-1 rounded-r-2xl shadow-lg animate-slide-in-left animate-pulse transform -rotate-90 origin-left">
            Created by Rex Merciline
        </p>
    </div>

    <script>
        // Chess piece Unicode symbols
        const PIECES = {
            'white': {
                'king': '♔', 'queen': '♕', 'rook': '♖', 'bishop': '♗', 'knight': '♘', 'pawn': '♙'
            },
            'black': {
                'king': '♚', 'queen': '♛', 'rook': '♜', 'bishop': '♝', 'knight': '♞', 'pawn': '♟'
            }
        };

        // Chess Learning Tips
        const CHESS_TIPS = [
            "Control the center of the board with your pawns and pieces. The four central squares (e4, e5, d4, d5) are the most important!",
            "Develop your knights before bishops. Knights on f3 and c3 (for white) control important central squares.",
            "Castle early to keep your king safe. Don't leave your king in the center too long!",
            "Don't move the same piece twice in the opening unless you have to. Develop different pieces instead.",
            "Look for tactics like forks, pins, and skewers to win material from your opponent.",
            "In the endgame, activate your king! The king becomes a powerful piece when there are fewer pieces on the board.",
            "Control open files with your rooks. Rooks are most effective on open or semi-open files.",
            "Before making a move, ask yourself: What is my opponent threatening? How can I improve my position?",
            "Don't trade pieces without a reason. Each trade should improve your position or solve a problem.",
            "Learn basic checkmate patterns like Queen + King vs King, and Rook + King vs King."
        ];

        class ChessGame {
            constructor() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.gameStatus = 'active';
                this.lastMove = null;
                this.hintsUsed = 0;
                this.aiEnabled = false;
                this.gameStartTime = Date.now();
                this.currentTip = 0;
                this.isMobile = window.innerWidth <= 768;
                
                this.initializeUI();
                this.setupMobileControls();
                this.renderBoard();
                this.updateGameInfo();
                this.startTimer();
                this.rotateTips();
                this.setupTouchFeedback();
            }

            initializeBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Place pieces
                const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                // Black pieces
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: backRow[col], color: 'black' };
                    board[1][col] = { type: 'pawn', color: 'black' };
                }
                
                // White pieces
                for (let col = 0; col < 8; col++) {
                    board[6][col] = { type: 'pawn', color: 'white' };
                    board[7][col] = { type: backRow[col], color: 'white' };
                }
                
                return board;
            }

            initializeUI() {
                // Desktop controls
                //document.getElementById('new-game-btn')?.addEventListener('click', () => this.newGame());
                document.getElementById('undo-btn')?.addEventListener('click', () => this.undoMove());
                document.getElementById('hint-btn')?.addEventListener('click', () => this.showHint());
                document.getElementById('ai-move-btn')?.addEventListener('click', () => this.makeAIMove());
                document.getElementById('toggle-ai-btn')?.addEventListener('click', () => this.toggleAI());
            }

            setupMobileControls() {
                // Mobile menu toggle
                const menuToggle = document.getElementById('menu-toggle');
                const mobileMenu = document.getElementById('mobile-menu');
                const hamburgerMenu = document.querySelector('.hamburger-menu');

                menuToggle?.addEventListener('click', () => {
                    mobileMenu.classList.toggle('open');
                    hamburgerMenu.classList.toggle('active');
                });

                // Mobile control buttons
               // document.getElementById('mobile-new-game')?.addEventListener('click', () => this.newGame());
                document.getElementById('mobile-undo')?.addEventListener('click', () => this.undoMove());
                document.getElementById('mobile-hint')?.addEventListener('click', () => this.showHint());
                document.getElementById('mobile-ai-move')?.addEventListener('click', () => this.makeAIMove());
                document.getElementById('mobile-toggle-ai')?.addEventListener('click', () => this.toggleAI());

                // Modal controls
                document.getElementById('modal-close')?.addEventListener('click', () => this.closeModal());
                document.getElementById('modal-ok')?.addEventListener('click', () => this.closeModal());
                document.getElementById('modal')?.addEventListener('click', (e) => {
                    if (e.target.id === 'modal') this.closeModal();
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.isMobile = window.innerWidth <= 768;
                    this.updateGameInfo();
                });

                // Prevent zoom on double tap
                document.addEventListener('touchend', (e) => {
                    if (e.target.closest('.chess-square')) {
                        e.preventDefault();
                    }
                });
            }

            setupTouchFeedback() {
                document.addEventListener('touchstart', (e) => {
                    if (e.target.closest('.chess-square')) {
                        this.createRipple(e);
                    }
                });
            }

            createRipple(e) {
                const square = e.target.closest('.chess-square');
                if (!square) return;

                const ripple = document.createElement('div');
                const rect = square.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                const touch = e.touches[0];
                const x = touch.clientX - rect.left - size / 2;
                const y = touch.clientY - rect.top - size / 2;

                ripple.className = 'touch-ripple';
                ripple.style.width = ripple.style.height = size + 'px';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';

                square.appendChild(ripple);

                setTimeout(() => {
                    ripple.remove();
                }, 600);
            }

            renderBoard() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = 'chess-square';
                        square.classList.add((row + col) % 2 === 0 ? 'light-square' : 'dark-square');
                        square.dataset.row = row;
                        square.dataset.col = col;

                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('span');
                            pieceElement.className = 'piece';
                            pieceElement.textContent = PIECES[piece.color][piece.type];
                            square.appendChild(pieceElement);
                        }

                        // Add click/touch events
                        square.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.handleSquareClick(row, col);
                        });

                        square.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            this.handleSquareClick(row, col);
                        });

                        boardElement.appendChild(square);
                    }
                }

                this.highlightSquares();
            }

            handleSquareClick(row, col) {
                if (this.gameStatus !== 'active') return;

                const piece = this.board[row][col];
                
                // If clicking on own piece, select it
                if (piece && piece.color === this.currentPlayer) {
                    this.selectSquare(row, col);
                }
                // If a square is selected and this is a valid move, make the move
                else if (this.selectedSquare && this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                    this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                }
                // Otherwise, deselect
                else {
                    this.deselectSquare();
                }
            }

            selectSquare(row, col) {
                this.selectedSquare = { row, col };
                this.possibleMoves = this.getPossibleMoves(row, col);
                this.renderBoard();
            }

            deselectSquare() {
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.renderBoard();
            }

            highlightSquares() {
                const squares = document.querySelectorAll('.chess-square');
                squares.forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);

                    // Highlight selected square
                    if (this.selectedSquare && this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        square.classList.add('selected');
                    }

                    // Highlight possible moves
                    if (this.possibleMoves.some(move => move.row === row && move.col === col)) {
                        square.classList.add('possible-move');
                    }

                    // Highlight last move
                    if (this.lastMove && 
                        ((this.lastMove.from.row === row && this.lastMove.from.col === col) ||
                         (this.lastMove.to.row === row && this.lastMove.to.col === col))) {
                        square.classList.add('last-move');
                    }

                    // Highlight king in check
                    const piece = this.board[row][col];
                    if (piece && piece.type === 'king' && this.isInCheck(piece.color)) {
                        square.classList.add('in-check');
                    }
                });
            }

            getPossibleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                const moves = [];
                
                switch (piece.type) {
                    case 'pawn':
                        moves.push(...this.getPawnMoves(row, col, piece.color));
                        break;
                    case 'rook':
                        moves.push(...this.getRookMoves(row, col, piece.color));
                        break;
                    case 'knight':
                        moves.push(...this.getKnightMoves(row, col, piece.color));
                        break;
                    case 'bishop':
                        moves.push(...this.getBishopMoves(row, col, piece.color));
                        break;
                    case 'queen':
                        moves.push(...this.getQueenMoves(row, col, piece.color));
                        break;
                    case 'king':
                        moves.push(...this.getKingMoves(row, col, piece.color));
                        break;
                }

                // Filter moves that would leave king in check
                return moves.filter(move => !this.wouldBeInCheck(piece.color, row, col, move.row, move.col));
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;

                // Forward move
                if (this.isValidPosition(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push({ row: row + direction, col });
                    
                    // Double move from starting position
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push({ row: row + 2 * direction, col });
                    }
                }

                // Diagonal captures
                for (const deltaCol of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + deltaCol;
                    if (this.isValidPosition(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (targetPiece && targetPiece.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }

                return moves;
            }

            getRookMoves(row, col, color) {
                const moves = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

                for (const [deltaRow, deltaCol] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * deltaRow;
                        const newCol = col + i * deltaCol;
                        
                        if (!this.isValidPosition(newRow, newCol)) break;
                        
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.color !== color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            getKnightMoves(row, col, color) {
                const moves = [];
                const knightMoves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];

                for (const [deltaRow, deltaCol] of knightMoves) {
                    const newRow = row + deltaRow;
                    const newCol = col + deltaCol;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }

                return moves;
            }

            getBishopMoves(row, col, color) {
                const moves = [];
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];

                for (const [deltaRow, deltaCol] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + i * deltaRow;
                        const newCol = col + i * deltaCol;
                        
                        if (!this.isValidPosition(newRow, newCol)) break;
                        
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (targetPiece.color !== color) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                    }
                }

                return moves;
            }

            getQueenMoves(row, col, color) {
                return [...this.getRookMoves(row, col, color), ...this.getBishopMoves(row, col, color)];
            }

            getKingMoves(row, col, color) {
                const moves = [];
                const directions = [
                    [-1, -1], [-1, 0], [-1, 1],
                    [0, -1],           [0, 1],
                    [1, -1],  [1, 0],  [1, 1]
                ];

                for (const [deltaRow, deltaCol] of directions) {
                    const newRow = row + deltaRow;
                    const newCol = col + deltaCol;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece || targetPiece.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                    }
                }

                return moves;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                const possibleMoves = this.getPossibleMoves(fromRow, fromCol);
                return possibleMoves.some(move => move.row === toRow && move.col === toCol);
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];

                // Record move for history
                const moveNotation = this.getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece);
                
                // Make the move
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;

                // Handle captured piece
                if (capturedPiece) {
                    this.capturedPieces[capturedPiece.color].push(capturedPiece);
                }

                // Handle pawn promotion
                if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = { type: 'queen', color: piece.color };
                    this.showNotification('Pawn promoted to Queen!');
                }

                // Record move
                this.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
                this.moveHistory.push({
                    notation: moveNotation,
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    piece: { ...piece },
                    captured: capturedPiece ? { ...capturedPiece } : null,
                    board: this.board.map(row => row.map(cell => cell ? { ...cell } : null))
                });

                // Switch players
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';

                // Check game status
                this.checkGameStatus();

                // Update UI
                this.deselectSquare();
                this.renderBoard();
                this.updateGameInfo();

                // AI move if enabled
                if (this.aiEnabled && this.currentPlayer === 'black' && this.gameStatus === 'active') {
                    setTimeout(() => this.makeAIMove(), 1000);
                }
            }

            getMoveNotation(fromRow, fromCol, toRow, toCol, piece, capturedPiece) {
                const files = 'abcdefgh';
                const fromSquare = files[fromCol] + (8 - fromRow);
                const toSquare = files[toCol] + (8 - toRow);
                
                let notation = '';
                if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                    notation = toCol > fromCol ? 'O-O' : 'O-O-O';
                } else {
                    if (piece.type !== 'pawn') {
                        notation += piece.type.charAt(0).toUpperCase();
                    }
                    if (capturedPiece) {
                        if (piece.type === 'pawn') {
                            notation += files[fromCol];
                        }
                        notation += 'x';
                    }
                    notation += toSquare;
                }
                
                return notation;
            }

            undoMove() {
                if (this.moveHistory.length === 0) {
                    this.showNotification('No moves to undo');
                    return;
                }

                const lastMove = this.moveHistory.pop();
                
                // Restore board state
                this.board = lastMove.board;
                
                // Restore captured pieces
                if (lastMove.captured) {
                    const capturedList = this.capturedPieces[lastMove.captured.color];
                    const index = capturedList.findIndex(p => 
                        p.type === lastMove.captured.type && p.color === lastMove.captured.color
                    );
                    if (index > -1) {
                        capturedList.splice(index, 1);
                    }
                }

                // Switch back player
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Update last move
                this.lastMove = this.moveHistory.length > 0 ? this.moveHistory[this.moveHistory.length - 1] : null;
                
                // Reset game status if it was ended
                this.gameStatus = 'active';

                this.deselectSquare();
                this.renderBoard();
                this.updateGameInfo();
                this.showNotification('Move undone');
            }

            showHint() {
                if (this.gameStatus !== 'active') {
                    this.showNotification('Game is not active');
                    return;
                }

                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === this.currentPlayer) {
                            const moves = this.getPossibleMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({
                                    from: { row, col },
                                    to: move,
                                    piece: piece
                                });
                            });
                        }
                    }
                }

                if (allMoves.length === 0) {
                    this.showNotification('No valid moves available');
                    return;
                }

                // Simple hint: suggest a random valid move
                const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                
                // Highlight the suggested move
                const fromSquare = document.querySelector(`[data-row="${randomMove.from.row}"][data-col="${randomMove.from.col}"]`);
                const toSquare = document.querySelector(`[data-row="${randomMove.to.row}"][data-col="${randomMove.to.col}"]`);
                
                if (fromSquare && toSquare) {
                    const fromHint = document.createElement('div');
                    fromHint.className = 'hint-overlay';
                    fromSquare.appendChild(fromHint);
                    
                    const toHint = document.createElement('div');
                    toHint.className = 'hint-overlay';
                    toSquare.appendChild(toHint);
                    
                    setTimeout(() => {
                        fromHint.remove();
                        toHint.remove();
                    }, 3000);
                }

                this.hintsUsed++;
                this.updateGameInfo();
                
                const files = 'abcdefgh';
                const fromNotation = files[randomMove.from.col] + (8 - randomMove.from.row);
                const toNotation = files[randomMove.to.col] + (8 - randomMove.to.row);
                
                this.showNotification(`Hint: Consider moving ${randomMove.piece.type} from ${fromNotation} to ${toNotation}`);
            }

            makeAIMove() {
                if (this.gameStatus !== 'active') {
                    this.showNotification('Game is not active');
                    return;
                }
                
                if (this.currentPlayer === 'white') {
                    this.showNotification('It\'s not AI\'s turn');
                    return;
                }

                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === 'black') {
                            const moves = this.getPossibleMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({
                                    from: { row, col },
                                    to: move
                                });
                            });
                        }
                    }
                }

                if (allMoves.length === 0) {
                    this.showNotification('AI has no valid moves');
                    return;
                }

                // Simple AI: prioritize captures, then random moves
                const captureMoves = allMoves.filter(move => this.board[move.to.row][move.to.col] !== null);
                const moveToMake = captureMoves.length > 0 ? 
                    captureMoves[Math.floor(Math.random() * captureMoves.length)] :
                    allMoves[Math.floor(Math.random() * allMoves.length)];

                this.makeMove(moveToMake.from.row, moveToMake.from.col, moveToMake.to.row, moveToMake.to.col);
            }

            toggleAI() {
                this.aiEnabled = !this.aiEnabled;
                
                // Update desktop button
                const desktopButton = document.getElementById('toggle-ai-btn');
                if (desktopButton) {
                    desktopButton.innerHTML = this.aiEnabled ? 
                        '<i class="fas fa-brain mr-2"></i>AI: ON' : 
                        '<i class="fas fa-brain mr-2"></i>AI: OFF';
                    desktopButton.className = this.aiEnabled ? 
                        'control-button bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-lg' :
                        'control-button bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg';
                }
                
                // Update mobile button
                const mobileButton = document.getElementById('mobile-toggle-ai');
                if (mobileButton) {
                    mobileButton.innerHTML = this.aiEnabled ? 
                        '<i class="fas fa-brain mr-1"></i>AI: ON' : 
                        '<i class="fas fa-brain mr-1"></i>AI: OFF';
                    mobileButton.className = this.aiEnabled ? 
                        'control-button bg-green-500 text-white px-4 py-2 rounded-lg flex-1 text-sm' :
                        'control-button bg-blue-500 text-white px-4 py-2 rounded-lg flex-1 text-sm';
                }
                
                this.showNotification(`AI ${this.aiEnabled ? 'enabled' : 'disabled'}`);
            }

            isInCheck(color) {
                // Find the king
                let kingPos = null;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === 'king' && piece.color === color) {
                            kingPos = { row, col };
                            break;
                        }
                    }
                    if (kingPos) break;
                }

                if (!kingPos) return false;

                // Check if any opponent piece can attack the king
                const opponentColor = color === 'white' ? 'black' : 'white';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === opponentColor) {
                            const moves = this.getPossibleMovesIgnoringCheck(row, col);
                            if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            getPossibleMovesIgnoringCheck(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];

                switch (piece.type) {
                    case 'pawn': return this.getPawnMoves(row, col, piece.color);
                    case 'rook': return this.getRookMoves(row, col, piece.color);
                    case 'knight': return this.getKnightMoves(row, col, piece.color);
                    case 'bishop': return this.getBishopMoves(row, col, piece.color);
                    case 'queen': return this.getQueenMoves(row, col, piece.color);
                    case 'king': return this.getKingMoves(row, col, piece.color);
                    default: return [];
                }
            }

            wouldBeInCheck(color, fromRow, fromCol, toRow, toCol) {
                // Make temporary move
                const originalPiece = this.board[toRow][toCol];
                const movingPiece = this.board[fromRow][fromCol];
                
                this.board[toRow][toCol] = movingPiece;
                this.board[fromRow][fromCol] = null;

                const inCheck = this.isInCheck(color);

                // Restore board
                this.board[fromRow][fromCol] = movingPiece;
                this.board[toRow][toCol] = originalPiece;

                return inCheck;
            }

            checkGameStatus() {
                const inCheck = this.isInCheck(this.currentPlayer);
                const hasValidMoves = this.hasValidMoves(this.currentPlayer);

                if (inCheck && !hasValidMoves) {
                    this.gameStatus = 'checkmate';
                    const winner = this.currentPlayer === 'white' ? 'Black' : 'White';
                    this.showNotification(`Game Over! Checkmate! ${winner} wins!`);
                    } else if (!hasValidMoves) {
                        this.gameStatus = 'stalemate';
                        this.showNotification('Game Over! Stalemate! It\'s a draw!');
                        } else if (inCheck) {
                            this.showNotification('Check!');
                            }
            }

            hasValidMoves(color) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.color === color) {
                            const moves = this.getPossibleMoves(row, col);
                            if (moves.length > 0) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            updateGameInfo() {
                const currentPlayerText = `${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}'s Turn`;
                
                // Update desktop elements
                const currentPlayerEl = document.getElementById('current-player');
                if (currentPlayerEl) {
                    currentPlayerEl.textContent = currentPlayerText;
                }

                // Update mobile elements
                const mobileCurrentPlayerEl = document.getElementById('mobile-current-player');
                if (mobileCurrentPlayerEl) {
                    mobileCurrentPlayerEl.textContent = this.currentPlayer === 'white' ? 'White' : 'Black';
                }

                // Update game status
                const statusElements = [document.getElementById('game-status'), document.getElementById('mobile-game-status')];
                statusElements.forEach(statusElement => {
                    if (!statusElement) return;
                    
                    if (this.gameStatus === 'checkmate') {
                        const winner = this.currentPlayer === 'white' ? 'Black' : 'White';
                        statusElement.textContent = `${winner} Wins!`;
                        statusElement.className = statusElement.className.replace('text-gray-600', 'text-red-600 font-bold');
                    } else if (this.gameStatus === 'stalemate') {
                        statusElement.textContent = 'Draw!';
                        statusElement.className = statusElement.className.replace('text-gray-600', 'text-yellow-600 font-bold');
                    } else if (this.isInCheck(this.currentPlayer)) {
                        statusElement.textContent = 'Check!';
                        statusElement.className = statusElement.className.replace('text-gray-600', 'text-red-600 font-bold');
                    } else {
                        statusElement.textContent = '';
                        statusElement.className = statusElement.className.replace('text-red-600 font-bold', 'text-gray-600')
                            .replace('text-yellow-600 font-bold', 'text-gray-600');
                    }
                });

                // Update status bar
                const statusBar = document.getElementById('status-bar');
                if (statusBar) {
                    statusBar.className = `status-indicator ${this.currentPlayer === 'white' ? 'bg-blue-500' : 'bg-gray-800'} rounded`;
                }

                // Update captured pieces
                const whiteCaptured = this.capturedPieces.white.map(p => PIECES.white[p.type]).join(' ');
                const blackCaptured = this.capturedPieces.black.map(p => PIECES.black[p.type]).join(' ');
                
                const whiteCapturedEls = [document.getElementById('white-captured'), document.getElementById('mobile-white-captured')];
                const blackCapturedEls = [document.getElementById('black-captured'), document.getElementById('mobile-black-captured')];
                
                whiteCapturedEls.forEach(el => {
                    if (el) el.textContent = whiteCaptured;
                });
                blackCapturedEls.forEach(el => {
                    if (el) el.textContent = blackCaptured;
                });

                // Update move history
                const historyElements = [document.getElementById('move-history'), document.getElementById('mobile-move-history')];
                historyElements.forEach(historyElement => {
                    if (!historyElement) return;
                    
                    historyElement.innerHTML = '';
                    this.moveHistory.forEach((move, index) => {
                        const moveElement = document.createElement('div');
                        moveElement.className = 'flex justify-between items-center p-1 rounded hover:bg-gray-100';
                        moveElement.innerHTML = `
                            <span class="text-gray-600">${Math.floor(index / 2) + 1}${index % 2 === 0 ? '.' : '...'}</span>
                            <span class="font-mono">${move.notation}</span>
                        `;
                        historyElement.appendChild(moveElement);
                    });
                    historyElement.scrollTop = historyElement.scrollHeight;
                });

                // Update statistics
                const moveCount = this.moveHistory.length;
                const movesElements = [document.getElementById('moves-count'), document.getElementById('mobile-moves-count'), document.getElementById('mobile-moves')];
                const hintsElements = [document.getElementById('hints-count'), document.getElementById('mobile-hints-count')];
                
                movesElements.forEach(el => {
                    if (el) el.textContent = moveCount;
                });
                hintsElements.forEach(el => {
                    if (el) el.textContent = this.hintsUsed;
                });
            }

            newGame() {
                this.board = this.initializeBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.gameStatus = 'active';
                this.lastMove = null;
                this.hintsUsed = 0;
                this.gameStartTime = Date.now();

                this.renderBoard();
                this.updateGameInfo();
                this.showNotification('New game started!');
            }

            startTimer() {
                setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.gameStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    
                    const timeElements = [document.getElementById('game-time'), document.getElementById('mobile-timer')];
                    timeElements.forEach(el => {
                        if (el) el.textContent = timeString;
                    });
                }, 1000);
            }

            rotateTips() {
                setInterval(() => {
                    this.currentTip = (this.currentTip + 1) % CHESS_TIPS.length;
                    const tipElements = [document.getElementById('chess-tip'), document.getElementById('mobile-chess-tip')];
                    tipElements.forEach(el => {
                        if (el) el.textContent = CHESS_TIPS[this.currentTip];
                    });
                }, 10000);
            }

            showNotification(message) {
                const notification = document.getElementById('notification');
                const text = document.getElementById('notification-text');
                if (text) text.textContent = message;
                if (notification) notification.classList.add('show');
                
                setTimeout(() => {
                    if (notification) notification.classList.remove('show');
                }, 3000);
            }

            showModal(title, message) {
                const modal = document.getElementById('modal');
                const modalTitle = document.getElementById('modal-title');
                const modalBody = document.getElementById('modal-body');
                
                if (modalTitle) modalTitle.textContent = title;
                if (modalBody) modalBody.textContent = message;
                if (modal) modal.classList.remove('hidden');
            }

            closeModal() {
                const modal = document.getElementById('modal');
                if (modal) modal.classList.add('hidden');
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ChessGame();
        });

        // Prevent context menu on long press
        document.addEventListener('contextmenu', (e) => {
            if (e.target.closest('.chess-square')) {
                e.preventDefault();
            }
        });

        // Prevent double-tap zoom
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    </script>
</body>
</html>
